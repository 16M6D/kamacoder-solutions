# 整数的不同位数

[题目链接](https://kamacoder.com/problem.php?id=1049)

## C++
```c++
#include <bits/stdc++.h>
using namespace std;
  
int n, m;

void solve() {
    // 使用异或运算,不同的二进制位变为1
    // 则题目转化为求异或运算结果中1的个数
    int diff = n ^ m;
    int cnt = 0;
    // diff 和 (diff - 1)进行&运算可以消除末尾的1
    // 这种做法可以快速统计diff中1的个数,有几个1就只需要进行几次
    // 最后得出的cnt就是答案
    while(diff) {
        diff &= (diff - 1);
        cnt++;
    }
    cout << cnt << endl;
}


int main() {
    while(cin >> n >> m) {
        solve();    
    }
    return 0;
}
```
## Java

```java
/**
 * 思路：使用异或运算
 * 异或运算的性质，如果两个对应位置上的二进制数字不同，则结果为 1，如果相同，则为 0
 * 
 * 算法步骤：
 * 对给定的两个整数 m 和 n 进行异或运算，得到结果 xorResult。
 * 
 * 初始化一个计数器 count 为 0，用于统计 xorResult 中1的个数。
 * 
 * 循环遍历 xorResult 的每一位：
 *     检查 xorResult 最低位是否为1，如果是则递增 count。
 *     右移 xorResult 一位，以继续检查下一位。
 * 
 * 返回 count，即为二进制中不同位数的个数。
 * 
*/
import java.util.Scanner;

public class Main {
    public static int hammingDistance(int m, int n) {
        int xorResult = m ^ n; // 异或操作会生成一个新的整数，其二进制表示中的每一位表示m和n对应位是否相同
        int count = 0; // 初始化计数器
        while (xorResult != 0) {
            count += xorResult & 1; // 检查最低位是否为1，然后递增计数器
            xorResult >>= 1; // 右移异或结果
        }
        return count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int m = scanner.nextInt();
        int n = scanner.nextInt();
        int result = hammingDistance(m, n);
        System.out.println(result);
    }
}
```

## Python

## Go

## Js

## C
