# 41. 岛屿数量

[题目链接](https://kamacoder.com/problem.php?id=1041)

## C++

## Java

```java
/**
 * 思路：可以使用并查集来解决该问题。每次 addLand 时，可以将新加入的陆地与其相邻的陆地进行合并，
 * 然后计算岛屿的数量。
 * 
 * 首先创建一维数组，表示每个单元格的父节点，初始每个单元格的父节点都设置为自己。
 * 再初始化一个变量用于记录岛屿的数量
 * 
 * 对于每次 addLand 操作，首先将父节点设置为自己，然后检查周围的上下左右四个单元格，
 * 如果相邻的单元格也是陆地，则将当前的单元格与相邻的单元格进行合并（将当前单元格的父节点设置为另外一个单元格）
 * 同时岛屿的数量 -1
 * 
 * 每次 addLand 操作后，将当前的岛屿数量存入结果列表。
*/
import java.util.*;

public class Main {
  // 4个方向
  final static int[][] dir = {{1, -1, 0, 0}, {0, 0, 1, -1}};
  /**
   * 在并查集中，我们需要为每个单元格或节点分配一个唯一的标识符，以便能够在操作中识别它们。
   * 二维地图中的每个单元格可以由其行号和列号唯一确定。然而，并查集的数据结构是基于数组实现的，而数组是一维的。
   * 因此，我们需要将二维的坐标映射到一维的索引，以便在数组中表示这些单元格。
   * 考虑一个 m 行 n 列的二维地图，可以用 (row, col) 表示其中一个单元格的坐标。
   * 通过映射这个坐标到一维数组中的索引，我们可以使用一个一维数组来表示这个二维地图，并进行并查集的操作。
   * 映射的方式很多，只需要保证每个单元格都有一个唯一的一维索引，而且不会与其他单元格冲突。
   **/
  static int hashCor(int r, int c, int col) {
    return r * col + c + 1;// 加一是因为要将 0 当作水，加上 1 避免和 0 冲突
  }
  // 如果par[x] 为 0，则代表该点是水
  static int[] par, rank;
  static int find(int x) {
    return x == par[x] ? x : (par[x] = find(par[x]));
  }
  static void union(int x, int y) {
    if ((x = find(x)) == (y = find(y)))
      return;
    if (rank[x] < rank[y]) {
      par[x] = y;
    } else {
      par[y] = x;
      if (rank[x] == rank[y])
        rank[x]++;
    }
  }
  static boolean same(int x, int y) {
    return find(x) == find(y);
  }
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int isNum;    // 当前存在的岛屿个数。
    int row, col;  // 地图的行数与列数
    int i;
    int r, c;  // 当前正在处理的单元格的坐标
    int opNum;  // addLand 的总次数
    int nearR, nearC; // 相邻单元格的坐标
    while (sc.hasNext()) {
      row = sc.nextInt();
      col = sc.nextInt();
      opNum = sc.nextInt();
      isNum = 0;
      par = new int[row * col + 1]; // 一开始每个点的父节点均为0，代表水
      rank = new int[row * col + 1];
      while (opNum-- > 0) {
        r = sc.nextInt();
        c = sc.nextInt();
        // 如果行号r和列号c不越界且该点当前是水
        if (r >= 0 && r < row && c >= 0 && c < col && find(hashCor(r,c,col)) == 0){
          isNum++;
          par[hashCor(r, c, col)] = hashCor(r, c, col);
          for (i = 0; i < 4; ++i) {//遍历临近 4 个点的坐标
            nearR = r + dir[0][i];
            nearC = c + dir[1][i];
            // 如果该点不越界且是一块陆地且和当前的这一点不属于同一个岛
            if (nearR >= 0 && nearR < row && nearC >= 0 && nearC < col &&
                find(hashCor(nearR, nearC, col)) != 0 &&
                !same(hashCor(nearR, nearC, col), hashCor(r, c, col))) {
              // 那么把它们连成同一个岛
              union(hashCor(nearR, nearC, col), hashCor(r, c, col));
              isNum--;// 因为把两块不同的岛连成同一个岛了，所以岛的数目减一
            }
          }
        }
        System.out.printf("%d%c", isNum, opNum==0 ? '\n' : ' ');
      }
    }
  }
}
```

## Python

## Go

## JS

## C