# 53. 寻宝

[题目链接](https://kamacoder.com/problem.php?id=1053)

## C++
```c++
// Prim最小生成树算法
#include<bits/stdc++.h>
using namespace std;

int n, m;

void solve() {
    // 存储边,代表两个边之间的距离,初始化为一个很大的值,这代表一开始没有路径
    vector<vector<int>> grid(n, vector<int>(n, 0x3f3f3f3f)); 
    for(int i = 0; i < m; ++i) { 
        int x, y, k;
        cin >> x >> y >> k;
        // 因为是无向图,所以这里两个方向都要填上k
        grid[x - 1][y - 1] = k;
        grid[y - 1][x - 1] = k;
    }
    // 用来记录前驱节点到该节点的最小距离
    vector<int> minDist(n, 0x3f3f3f3f);
    // 用来记录节点是否在最小生成树中
    vector<bool> isInTree(n, false);
    // 通用的模板中需要一个parent数组,用来记录前驱结点
    // 但本题不需要知道路径
    // 所以不用parent数组也可以得到答案
    // vector<int> parent(n, 0x3f3f3f3f);
    minDist[0] = 0;
    // 需要找到n - 1条边
    for(int k = 0; k < n - 1; ++k) {
        // vec用来表示当前找到的距离最近的节点
        int vec = -1;
        // 找到当前的最近节点,注意是未在最小生成树中的节点
        for(int i = 0; i < n; ++i) {
            if(!isInTree[i] && (vec == -1 || minDist[i] < minDist[vec])) {
                vec = i;
            }
        }
        // 标记该节点已经加入最小生成树
        isInTree[vec] = true;
        // 更新目前找到的这个节点到其他节点的最小值
        // 注意这里也需要其他节点是未被加入最小生成树的
        for(int i = 0; i < n; ++i) {
            if(!isInTree[i] && grid[vec][i] < minDist[i]) {
                minDist[i] = grid[vec][i];
                // 同理, 下面这个parent也可以隐去
                // parent[i] = vec; 
            }
        }
    }
    int ans = 0;
    // 得到路径和
    for(int i = 0; i < n; ++i) {
        ans += minDist[i];
    }
    cout << ans << endl;
}

int main() {
    while(cin >> n >> m) {
        solve();
    }
    return 0;
}
```
## Java

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    // 最小生成树的Prim算法
    public static void prim(int numberOfNodes, int numberOfEdges, int[][] graph) {
        int[] distanceToTree = new int[numberOfNodes + 1]; // 存储各个节点到生成树的距离
        boolean[] isInTree = new boolean[numberOfNodes + 1]; // 节点是否被加入到生成树中
        int[] parent = new int[numberOfNodes + 1]; // 节点的前驱节点

        Arrays.fill(distanceToTree, Integer.MAX_VALUE); // 初始化距离数组为一个很大的数
        distanceToTree[1] = 0; // 从 1 号节点开始生成

        for (int i = 0; i < numberOfNodes; i++) { // 每次循环选出一个点加入到生成树
            int closestNode = -1;
            for (int j = 1; j <= numberOfNodes; j++) { // 每个节点一次判断
                if (!isInTree[j] && (closestNode == -1 || distanceToTree[j] < distanceToTree[closestNode])) {
                    closestNode = j;
                }
            }

            isInTree[closestNode] = true; // 选择该点

            for (int k = 1; k <= numberOfNodes; k++) { // 更新生成树外的点到生成树的距离
                if (distanceToTree[k] > graph[closestNode][k] && !isInTree[k]) {
                    distanceToTree[k] = graph[closestNode][k]; // 更新距离
                    parent[k] = closestNode; // 从 closestNode 到 k 的距离更短，k 的前驱变为 closestNode.
                }
            }
        }
        int result = 0;
        for (int i = numberOfNodes; i > 1; i--) { // 计算最小生成树的权值
            result += graph[i][parent[i]];
        }
        System.out.println(result);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int numberOfNodes = scanner.nextInt();
        int numberOfEdges = scanner.nextInt();

        int[][] graph = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int i = 1; i <= numberOfNodes; i++) {
            Arrays.fill(graph[i], Integer.MAX_VALUE); // 各个点之间的距离初始化成很大的数
        }

        while (numberOfEdges-- > 0) {
            int nodeA = scanner.nextInt();
            int nodeB = scanner.nextInt();
            int weight = scanner.nextInt();
            graph[nodeA][nodeB] = weight; // 存储权重
            graph[nodeB][nodeA] = weight; // 无向图，存储两次。
        }

        prim(numberOfNodes, numberOfEdges, graph); // 求最小生成树
    }
}
```

## Python

## Go

## JS

## C
