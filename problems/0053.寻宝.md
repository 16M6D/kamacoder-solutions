# 53. 寻宝

[题目链接](https://kamacoder.com/problem.php?id=1053)

## C++

```c++
/* 
 * 可以用 kruskal 算法来求最小生成树
 * 将所有的边按照权值大小做升序排序，从权值最小的边开始选择，只要此边不和已选择的边一起构成环路，就可以选择它组成最小生成树
 * 可以通过并查集来判断两个节点是否连通便可以判断当前选择的边是否会和已选择的边构成环路
 */
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 并查集模板
class UF {
private:
    int count;              // 连通分量的个数
    vector<int> parent;     // 存储每个节点的根节点
public:
    UF(int n) : count(n) {
        parent.resize(n);
        for (int i = 0; i < n; ++i) parent[i] = i;
    }

    // 将节点 p 和节点 q 连通
    void unionNew(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootQ] = rootP;
        --count;
    }

    // 判断节点 p 和节点 q 是否连通
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    // 查找节点 x 的根节点
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }

    // 返回连通分量个数
    int getCount() {
        return count;
    }
};

int main() {
    int v, e;
    cin >> v >> e;
    vector<vector<int>> edges(e, vector<int>(3));
    for (auto& edge : edges) {
        cin >> edge[0] >> edge[1] >> edge[2];
    }

    // 对边按权值大小做升序排序
    sort(edges.begin(), edges.end(), [&] (const auto& a, const auto& b) {
        return a[2] < b[2];
    });

    // kruskal 算法
    UF uf(v);
    int res = 0;
    // 按权值从小到大遍历每条边，并判断当前的边是否会和已选择的边构成环路
    for (const auto& edge : edges) {
        int from = edge[0] - 1, to = edge[1] - 1, val = edge[2];
        // 若当前的边的起点和终点已经连通，则跳过
        if (uf.connected(from, to)) continue;
        // 若当前的边的起点和终点未连通，则将当前边的权值加入 res，并将起点和终点连通起来
        res += val;
        uf.unionNew(from, to);
        // 如果当前连通分量的个数为 1，则说明已经构建出了最小生成树，跳出循环
        if (uf.getCount() == 1) break;
    }
    cout << res << endl;
    return 0;
}
```

## Java

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    // 最小生成树的Prim算法
    public static void prim(int numberOfNodes, int numberOfEdges, int[][] graph) {
        int[] distanceToTree = new int[numberOfNodes + 1]; // 存储各个节点到生成树的距离
        boolean[] isInTree = new boolean[numberOfNodes + 1]; // 节点是否被加入到生成树中
        int[] parent = new int[numberOfNodes + 1]; // 节点的前驱节点

        Arrays.fill(distanceToTree, Integer.MAX_VALUE); // 初始化距离数组为一个很大的数
        distanceToTree[1] = 0; // 从 1 号节点开始生成

        for (int i = 0; i < numberOfNodes; i++) { // 每次循环选出一个点加入到生成树
            int closestNode = -1;
            for (int j = 1; j <= numberOfNodes; j++) { // 每个节点一次判断
                if (!isInTree[j] && (closestNode == -1 || distanceToTree[j] < distanceToTree[closestNode])) {
                    closestNode = j;
                }
            }

            isInTree[closestNode] = true; // 选择该点

            for (int k = 1; k <= numberOfNodes; k++) { // 更新生成树外的点到生成树的距离
                if (distanceToTree[k] > graph[closestNode][k] && !isInTree[k]) {
                    distanceToTree[k] = graph[closestNode][k]; // 更新距离
                    parent[k] = closestNode; // 从 closestNode 到 k 的距离更短，k 的前驱变为 closestNode.
                }
            }
        }
        int result = 0;
        for (int i = numberOfNodes; i > 1; i--) { // 计算最小生成树的权值
            result += graph[i][parent[i]];
        }
        System.out.println(result);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int numberOfNodes = scanner.nextInt();
        int numberOfEdges = scanner.nextInt();

        int[][] graph = new int[numberOfNodes + 1][numberOfNodes + 1];
        for (int i = 1; i <= numberOfNodes; i++) {
            Arrays.fill(graph[i], Integer.MAX_VALUE); // 各个点之间的距离初始化成很大的数
        }

        while (numberOfEdges-- > 0) {
            int nodeA = scanner.nextInt();
            int nodeB = scanner.nextInt();
            int weight = scanner.nextInt();
            graph[nodeA][nodeB] = weight; // 存储权重
            graph[nodeB][nodeA] = weight; // 无向图，存储两次。
        }

        prim(numberOfNodes, numberOfEdges, graph); // 求最小生成树
    }
}
```

## Python

## Go

## JS

## C