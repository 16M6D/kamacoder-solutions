# 38.填充矩阵I

[题目链接](https://kamacoder.com/problem.php?id=1038)

## C++

## Java

```java

/**
 * 思路：从内到外模拟过于麻烦，观察到可以从左上角到右下角进行逆向打印。
*/

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] array = generate2dArray2(n, m);
        print2dArray(array, n, m);
    }
    public static int[][] generate2dArray2(int n, int m) {
        int stop = 0;  // 结束条件
        int count = n * m;  // 用于填充二维数组的元素
        int startX = 0;
        int startY = 0;  
        int endX = n;
        int endY = m;
        int[][] twoDArray = new int[n][m];
        while (count > stop) {
            int i = startX;
            int j = startY;
            while (count > stop && j < endY) {  // 从左上到右上
                twoDArray[i][j++] = count--;
            }
            // 每 行/列 循环结束后，调整下一 行/列 开始遍历的位置。
            i++;
            j--;
            while (count > stop && i < endX) {  // 从右上到右下
                twoDArray[i++][j] = count--;
            }
            i--;
            j--;
            while (count > stop && j >= startY) { // 从右下到左下
                twoDArray[i][j--] = count--;
            }
            i--;
            j++;
            // i > startX 的原因是不能覆盖掉本次循环第一个填充的元素
            while (count > stop && i > startX) {  // 从左下到左上
                twoDArray[i--][j] = count--;
            }
            // 调整下一圈开始循环的位置
            startX++;
            startY++;
            endX--;
            endY--;
        }
        return twoDArray;
    }
    public static void print2dArray(int[][] twoDArray, int n, int m) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m - 1; j++) {
                System.out.printf("%d ", twoDArray[i][j]);
            }
            System.out.printf("%d\n", twoDArray[i][m - 1]);
        }
    }
}

```

## Python

## Go

## JS

## C